<script>
/* vortex → planets with orbit mask + planet halos (inline-orbits-r19)
   - Faster morph into vortex
   - Planets sync to real period ratios; initial phase from current date
   - Text fades out except near orbits and circular halos around planets
   - Grid-stepped letters (calm), 1 cell hop per ~0.6–0.3 s
*/
(function(){
  // Planet data (semi-major axis in AU, sidereal period in Earth days)
  const PLANETS = [
    {name:"Mercury", a:0.3871, P:87.969,  color:"#cbd5e1", r:2},
    {name:"Venus",   a:0.7233, P:224.701, color:"#fbbf24", r:3},
    {name:"Earth",   a:1.0000, P:365.256, color:"#60a5fa", r:3},
    {name:"Mars",    a:1.5237, P:686.980, color:"#f87171", r:3},
    {name:"Jupiter", a:5.2026, P:4332.59, color:"#f59e0b", r:4},
    {name:"Saturn",  a:9.5549, P:10759.2, color:"#fcd34d", r:4},
    {name:"Uranus",  a:19.218, P:30688.5, color:"#a78bfa", r:4},
    {name:"Neptune", a:30.110, P:60182.0, color:"#93c5fd", r:4}
  ];

  class VortexPlanets extends HTMLElement {
    connectedCallback(){
      // === Tunables ======================================================
      this.words = ["TRAJECTORY","PROPULSION","Δv","CFD","REENTRY","ORBITAL","STARSHIP","MARS","SPICE","ROVER","SCRAMJET","UAV"];

      // Grid + spiral
      const CELL_W=12, CELL_H=36;
      const ROWS=40, B=4.2;              // r = B*θ
      const CENTER_X=0.5, CENTER_Y=0.58;

      // Vortex timing (finish before planets appear)
      const BOOT_MS=2000;                // rows phase (idle)
      const MORPH_MS=900;                // rows→spiral duration
      const PLANETS_START_MORPH=0.98;    // planets/ orbits fade in after this

      // Swirl speed (faster than before)
      const SPEED_INTRO=0.0025;          // rad/s at morph start
      const SPEED_FINAL=0.0200;          // rad/s when fully spiraled

      // Grid-step cadence (faster hops but still calm)
      const STEP_INTRO_MS=600;           // ~0.6 s per allowed hop at start
      const STEP_FINAL_MS=320;           // ~0.32 s when fully spiraled

      // Fade: non-orbit text fades to 0 as morph→1
      const FADE_POWER = 1.6;

      // Orbit rings kept visible (thin)
      const ORBIT_BAND = 8;              // ±px around orbit to keep text

      // Planet halos (circular rings around each moving planet)
      const HALO_R   = 22;               // radius of halo (px)
      const HALO_BW  = 7;                // band width (px, ± around HALO_R)

      // Solar-system time scale (days simulated per animation second)
      const DAYS_PER_SEC = 30;           // Earth ≈ 12 s per revolution
      // ===================================================================

      const line = (this.words.join("•")+"•").replace(/ /g,"");

      // Canvas
      const cvs = document.createElement("canvas");
      const ctx = cvs.getContext("2d");
      this.appendChild(cvs);

      // Geometry + precompute
      const resize = () => {
        const dpr = Math.max(1, devicePixelRatio||1);
        cvs.width  = Math.floor(innerWidth*dpr);
        cvs.height = Math.floor(innerHeight*dpr);
        cvs.style.width  = innerWidth+"px";
        cvs.style.height = innerHeight+"px";
        ctx.setTransform(dpr,0,0,dpr,0,0);

        this.cx = innerWidth*CENTER_X;
        this.cy = innerHeight*CENTER_Y;

        // font & cell sanity
        this.fontPx = Math.max(10, Math.floor(CELL_H*0.61));
        ctx.font = `${this.fontPx}px "Courier New", monospace`;
        const mw = Math.ceil(ctx.measureText("M").width)+2;
        this.cellW = Math.max(CELL_W, mw);
        this.cellH = CELL_H;

        // grid
        this.cols = Math.max(1, Math.floor(innerWidth / this.cellW));
        this.rows = Math.max(1, ROWS);
        this.N    = Math.min(this.cols*this.rows, 12000);

        const maxR = Math.hypot(Math.max(this.cx, innerWidth-this.cx),
                                Math.max(this.cy, innerHeight-this.cy)) + 60;
        this.maxTheta = maxR / B;

        // θ inner→outer
        this.theta = new Float32Array(this.N);
        for (let i=0;i<this.N;i++) this.theta[i]=(i/this.N)*this.maxTheta;

        // grid mapping + state
        this.rcRow = new Int16Array(this.N);
        this.rcCol = new Int16Array(this.N);
        this.lastCi= new Int16Array(this.N);
        this.lastRi= new Int16Array(this.N);
        this.nextAt= new Float64Array(this.N);
        let k=0, now=performance.now();
        for (let r=0;r<this.rows && k<this.N;r++){
          for (let c=0;c<this.cols && k<this.N;c++,k++){
            this.rcRow[k]=r; this.rcCol[k]=c;
            this.lastCi[k]=c; this.lastRi[k]=r;
            this.nextAt[k]=now;
          }
        }
        this.occ = new Uint8Array(this.cols*this.rows);

        // scale AU → pixels so Neptune fits nicely near edge
        const minDim = Math.min(innerWidth, innerHeight);
        const maxAU  = 30.11;                    // Neptune
        const kpx    = (0.46 * minDim) / maxAU;  // scale factor px/AU
        this.orbits  = PLANETS.map(p => p.a * kpx);

        // planet initial angles from current date (simple mean anomaly)
        const daysNow = Date.now()/86400000; // days since 1970-01-01
        this.a0 = PLANETS.map(p => 2*Math.PI * ((daysNow % p.P) / p.P));
        // angular rates: ω = 2π * (days/sec) / P
        this.omega = PLANETS.map(p => 2*Math.PI * (DAYS_PER_SEC / p.P));
      };
      addEventListener("resize", resize, {passive:true}); resize();

      const ease = t => t<.5 ? 4*t*t*t : 1-(-2*t+2)**3/2;

      this.__version = "inline-orbits-r19";
      let tStart = performance.now(), tPrev = tStart;

      const tick = (now) => {
        const dt = Math.min(1/20, Math.max(0,(now - tPrev)/1000)); tPrev = now;

        ctx.clearRect(0,0,innerWidth,innerHeight);
        ctx.textAlign="center"; ctx.textBaseline="middle";

        // morph progress
        const mRaw = Math.min(1, Math.max(0,(now - tStart - BOOT_MS)/MORPH_MS));
        const morph = ease(mRaw);

        // speeds + step cadence
        const speedNow = SPEED_INTRO + (SPEED_FINAL - SPEED_INTRO)*morph;
        const stepMs   = STEP_INTRO_MS + (STEP_FINAL_MS - STEP_INTRO_MS)*morph;

        // planets visible only after vortex is basically done
        const planetsOn = morph >= PLANETS_START_MORPH;

        // slow character cycling
        const charOffset = Math.floor(now / 4000) % line.length;

        // Draw orbits only when planets are on
        if (planetsOn) {
          ctx.save();
          ctx.strokeStyle = "rgba(148,163,184,0.18)";
          ctx.lineWidth = 1;
          this.orbits.forEach(r=>{
            ctx.beginPath();
            ctx.arc(this.cx, this.cy, r, 0, Math.PI*2);
            ctx.stroke();
          });
          ctx.restore();
        }

        // Reset occupancy and draw letters
        this.occ.fill(0);
        const halfRowsH = (ROWS*this.cellH)/2;
        ctx.font = `${this.fontPx}px "Courier New", monospace`;

        for (let i=0;i<this.N;i++){
          let t = this.theta[i];
          if (t > this.maxTheta){ t -= this.maxTheta; this.theta[i]=t; }
          const r = B*t;

          // spiral vs row position
          const sx = this.cx + r*Math.cos(t);
          const sy = this.cy + r*Math.sin(t);
          const rx = (this.rcCol[i]+0.5)*this.cellW;
          const ry = (this.rcRow[i]+0.5)*this.cellH + (this.cy - halfRowsH);

          let x = rx*(1-morph) + sx*morph;
          let y = ry*(1-morph) + sy*morph;

          const ciT = Math.round(x / this.cellW);
          const riT = Math.round(y / this.cellH);

          // grid step with cooldown
          let ci = this.lastCi[i], ri = this.lastRi[i];
          if ((ciT!==ci || riT!==ri) && now >= this.nextAt[i]) {
            const dci = ciT - ci, dri = riT - ri;
            if (Math.abs(dci) >= Math.abs(dri)) ci += Math.sign(dci)||0;
            else ri += Math.sign(dri)||0;
            ci = Math.max(0, Math.min(this.cols-1, ci));
            ri = Math.max(0, Math.min(this.rows-1, ri));
            this.lastCi[i]=ci; this.lastRi[i]=ri;
            this.nextAt[i]= now + stepMs;
          }

          const key = ri*this.cols + ci;
          if (this.occ[key]) { this.theta[i]=t + speedNow*dt; continue; }
          this.occ[key]=1;

          const px = ci*this.cellW, py = ri*this.cellH;

          // base fade of non-orbit text as morph completes
          let alpha = Math.pow(1 - morph, FADE_POWER);

          if (planetsOn) {
            // keep letters near any orbit ring (thin band)
            const dist = Math.hypot(px - this.cx, py - this.cy);
            let orbitMask = 0;
            for (let k=0;k<this.orbits.length;k++){
              const d = Math.abs(dist - this.orbits[k]);
              const a = Math.max(0, 1 - d/ORBIT_BAND);
              if (a > orbitMask) orbitMask = a;
            }
            // keep letters in circular halos around each moving planet
            let haloMask = 0;
            for (let k=0;k<this.orbits.length;k++){
              const ang = this.a0[k] + this.omega[k] * ((now - tStart)/1000);
              const cx = this.cx + this.orbits[k] * Math.cos(ang);
              const cy = this.cy + this.orbits[k] * Math.sin(ang);
              const d  = Math.hypot(px - cx, py - cy);
              const a  = Math.max(0, 1 - Math.abs(d - HALO_R)/HALO_BW);
              if (a > haloMask) haloMask = a;
            }
            alpha = Math.max(alpha, orbitMask, haloMask);
          }

          if (alpha > 0.02) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = "#d7e0ee";
            const ch = line.charAt((i + charOffset) % line.length) || "•";
            ctx.fillText(ch, px, py);
          }

          // advance θ along spiral
          this.theta[i] = t + speedNow*dt;
        }
        ctx.globalAlpha = 1;

        // Draw planets (after morph)
        if (planetsOn) {
          ctx.save();
          for (let k=0;k<this.orbits.length;k++){
            const ang = this.a0[k] + this.omega[k] * ((now - tStart)/1000);
            const r   = this.orbits[k];
            const ax  = this.cx + r * Math.cos(ang);
            const ay  = this.cy + r * Math.sin(ang);
            // halo outline (thin)
            ctx.strokeStyle = "rgba(148,163,184,0.20)";
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(ax, ay, HALO_R, 0, Math.PI*2); ctx.stroke();
            // planet
            ctx.fillStyle = PLANETS[k].color;
            ctx.beginPath(); ctx.arc(ax, ay, PLANETS[k].r, 0, Math.PI*2); ctx.fill();
          }
          ctx.restore();
        }

        // HUD
        const el = document.getElementById('hud');
        if (el) el.textContent = `inline-orbits-r19 | morph=${morph.toFixed(2)} speed=${speedNow.toFixed(3)} rad/s`;
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }
  }

  // Register/replace element cleanly
  const TAG='vortex-ultraslow';
  if (!customElements.get(TAG)) {
    customElements.define(TAG, VortexPlanets);
  } else {
    const NewTag='vortex-ultraslow-r19';
    if (!customElements.get(NewTag)) customElements.define(NewTag, VortexPlanets);
    const old=document.querySelector(TAG); if (old) old.replaceWith(document.createElement(NewTag));
  }
})();
</script>
