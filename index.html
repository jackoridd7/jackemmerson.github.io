<script>
/* ultraslow vortex with orbit mask (inline-orbits-r18)
   - Slightly faster than r17
   - Letters fade out at end except those near orbit circles
   - One-letter-per-cell; grid-stepped: max one cell hop per ~0.9–0.7s
*/
(function(){
  class VortexUltraOrbits extends HTMLElement {
    connectedCallback(){
      // === Tunables ======================================================
      this.words = ["TRAJECTORY","PROPULSION","Δv","CFD","REENTRY","ORBITAL","STARSHIP","MARS","SPICE","ROVER","SCRAMJET","UAV"];

      // Spiral/grid
      const CELL_W=12, CELL_H=36;  // keep your 2× size
      const ROWS=40, B=4.2;        // r = B*θ
      const CENTER_X=0.5, CENTER_Y=0.58;
      const BOOT_MS=3000;          // rows phase (before morph starts)

      // Motion (a bit faster than r17)
      const SPEED_INTRO=0.00002;   // rad/s (gentle)
      const SPEED_FINAL=0.0012;    // rad/s (slow but readable)
      const STEP_INTRO_MS=900;     // max one cell hop / ~0.9s at start
      const STEP_FINAL_MS=700;     // ~0.7s after morph

      // Fade: as morph→1, base letters fade to 0; only orbit-band letters remain
      const FADE_POWER = 1.4;      // higher = faster fade near the end

      // Orbits (auto-scaled to viewport); band is the “keep letters” thickness
      const ORBIT_COUNT = 5;
      const ORBIT_INNER = 0.11;    // as fraction of min(viewport)
      const ORBIT_STEP  = 0.11;    // spacing fraction
      const ORBIT_BAND  = 12;      // ±px around each orbit where letters stay visible

      // Planet dots on each orbit (very slow)
      const PLANET_SPEED_MIN = 0.02; // rad/s *scale
      const PLANET_SPEED_MAX = 0.06;

      const VERSION="inline-orbits-r18";
      // ===================================================================

      const line = (this.words.join("•")+"•").replace(/ /g,"");

      const cvs = document.createElement("canvas");
      const ctx = cvs.getContext("2d");
      this.appendChild(cvs);

      const resize = () => {
        const dpr = Math.max(1, devicePixelRatio||1);
        cvs.width  = Math.floor(innerWidth*dpr);
        cvs.height = Math.floor(innerHeight*dpr);
        cvs.style.width  = innerWidth+"px";
        cvs.style.height = innerHeight+"px";
        ctx.setTransform(dpr,0,0,dpr,0,0);

        this.cx = innerWidth*CENTER_X;
        this.cy = innerHeight*CENTER_Y;

        // Font & cell sanity
        this.fontPx = Math.max(10, Math.floor(CELL_H*0.61));
        ctx.font = `${this.fontPx}px "Courier New", monospace`;
        const mw = Math.ceil(ctx.measureText("M").width)+2;
        this.cellW = Math.max(CELL_W, mw);
        this.cellH = CELL_H;

        // Grid
        this.cols = Math.max(1, Math.floor(innerWidth / this.cellW));
        this.rows = Math.max(1, ROWS);
        this.N    = Math.min(this.cols*this.rows, 12000);

        const maxR = Math.hypot(Math.max(this.cx, innerWidth-this.cx),
                                Math.max(this.cy, innerHeight-this.cy)) + 60;
        this.maxTheta = maxR / B;

        // θ inner → outer
        this.theta = new Float32Array(this.N);
        for (let i=0;i<this.N;i++) this.theta[i]=(i/this.N)*this.maxTheta;

        // Matrix mapping + state
        this.rcRow = new Int16Array(this.N);
        this.rcCol = new Int16Array(this.N);
        this.lastCi= new Int16Array(this.N);
        this.lastRi= new Int16Array(this.N);
        this.nextAt= new Float64Array(this.N);
        let k=0, now=performance.now();
        for (let r=0;r<this.rows && k<this.N;r++){
          for (let c=0;c<this.cols && k<this.N;c++,k++){
            this.rcRow[k]=r; this.rcCol[k]=c;
            this.lastCi[k]=c; this.lastRi[k]=r;
            this.nextAt[k]=now;
          }
        }
        this.occ = new Uint8Array(this.cols*this.rows);

        // Orbits (pixels from centre)
        const minDim = Math.min(innerWidth, innerHeight);
        this.orbits = new Array(ORBIT_COUNT).fill(0).map((_,i)=>
          (ORBIT_INNER + i*ORBIT_STEP) * minDim
        );

        // Planets: angle + speed per orbit
        this.planetA = this.orbits.map(()=> Math.random()*Math.PI*2);
        this.planetV = this.orbits.map(()=> (PLANET_SPEED_MIN + Math.random()*(PLANET_SPEED_MAX-PLANET_SPEED_MIN)) * 0.05); // slow scale
      };
      addEventListener("resize", resize, {passive:true}); resize();

      const ease = t => t<.5 ? 4*t*t*t : 1-(-2*t+2)**3/2;

      this.__version = VERSION;
      let tStart = performance.now(), tPrev = tStart;

      const tick = (now) => {
        const dt = Math.min(1/20, Math.max(0,(now - tPrev)/1000)); tPrev = now;

        ctx.clearRect(0,0,innerWidth,innerHeight);
        ctx.textAlign="center"; ctx.textBaseline="middle";

        // Morph + speeds
        const mRaw = Math.min(1, Math.max(0,(now - tStart - BOOT_MS)/1200));
        const morph = ease(mRaw);
        const speedNow = SPEED_INTRO + (SPEED_FINAL - SPEED_INTRO)*morph;
        const stepMs   = STEP_INTRO_MS + (STEP_FINAL_MS - STEP_INTRO_MS)*morph;

        // Character cycling: very slow
        const charOffset = Math.floor(now / 6000) % line.length;

        // Background orbit rings (very faint)
        ctx.save();
        ctx.strokeStyle = "rgba(148,163,184,0.18)";
        ctx.lineWidth = 1;
        this.orbits.forEach(r=>{
          ctx.beginPath();
          ctx.arc(this.cx, this.cy, r, 0, Math.PI*2);
          ctx.stroke();
        });
        ctx.restore();

        // Reset occupancy
        this.occ.fill(0);
        const halfRowsH = (ROWS*this.cellH)/2;

        // Draw letters (inner→outer)
        ctx.font = `${this.fontPx}px "Courier New", monospace`;
        ctx.fillStyle = "#d7e0ee";

        for (let i=0;i<this.N;i++){
          let t = this.theta[i];
          if (t > this.maxTheta){ t -= this.maxTheta; this.theta[i]=t; }
          const r = B*t;

          // Spiral pos
          const sx = this.cx + r*Math.cos(t);
          const sy = this.cy + r*Math.sin(t);

          // Row pos
          const rx = (this.rcCol[i] + 0.5) * this.cellW;
          const ry = (this.rcRow[i] + 0.5) * this.cellH + (this.cy - halfRowsH);

          // Mix → target cell
          let x = rx*(1-morph) + sx*morph;
          let y = ry*(1-morph) + sy*morph;
          const ciT = Math.round(x / this.cellW);
          const riT = Math.round(y / this.cellH);

          // Current snapped cell (grid-stepped)
          let ci = this.lastCi[i], ri = this.lastRi[i];
          if ((ciT!==ci || riT!==ri) && now >= this.nextAt[i]) {
            const dci = ciT - ci, dri = riT - ri;
            if (Math.abs(dci) >= Math.abs(dri)) ci += Math.sign(dci)||0;
            else ri += Math.sign(dri)||0;
            ci = Math.max(0, Math.min(this.cols-1, ci));
            ri = Math.max(0, Math.min(this.rows-1, ri));
            this.lastCi[i]=ci; this.lastRi[i]=ri;
            this.nextAt[i]= now + stepMs;
          }

          const key = ri*this.cols + ci;
          if (this.occ[key]) { this.theta[i]=t + speedNow*dt; continue; }
          this.occ[key]=1;

          const px = ci*this.cellW, py = ri*this.cellH;

          // Fade logic: keep letters close to any orbit; fade others with morph
          const dist = Math.hypot(px - this.cx, py - this.cy);
          let orbitMask = 0;
          for (let k=0;k<this.orbits.length;k++){
            const d = Math.abs(dist - this.orbits[k]);
            const a = Math.max(0, 1 - d/ORBIT_BAND); // 1 at center of band → 0 at band edge
            if (a > orbitMask) orbitMask = a;
          }
          const baseFade = Math.pow(1 - morph, FADE_POWER); // 1→0 over the last part
          const alpha = Math.max(orbitMask, baseFade);      // keep orbit letters, fade others
          if (alpha > 0.02) {
            ctx.globalAlpha = alpha;
            const ch = line.charAt((i + charOffset) % line.length) || "•";
            ctx.fillText(ch, px, py);
          }

          // Advance θ
          this.theta[i] = t + speedNow*dt;
        }
        ctx.globalAlpha = 1;

        // Planets (tiny dots slowly moving)
        ctx.save();
        ctx.fillStyle = "#93c5fd"; // soft blue
        for (let k=0;k<this.orbits.length;k++){
          this.planetA[k] += this.planetV[k] * dt; // very slow
          const r = this.orbits[k];
          const ax = this.cx + r * Math.cos(this.planetA[k]);
          const ay = this.cy + r * Math.sin(this.planetA[k]);
          ctx.beginPath();
          ctx.arc(ax, ay, 3, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();

        // HUD
        ctx.save();
        ctx.fillStyle="rgba(2,6,23,.6)"; ctx.fillRect(8,8,340,54);
        ctx.fillStyle="#cbd5e1";
        ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace";
        ctx.textAlign="left"; ctx.textBaseline="top";
        ctx.fillText(VERSION, 16,14);
        ctx.fillText(`morph=${morph.toFixed(2)} speed=${speedNow.toFixed(6)} rad/s step≈${Math.round(stepMs)}ms`, 16,30);
        ctx.restore();

        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }
  }
  if (!customElements.get('vortex-ultraslow')) {
    customElements.define('vortex-ultraslow', VortexUltraOrbits);   // keep the same tag you already used
  } else {
    // If an older definition exists, register our orbit version under a fresh tag and swap it in.
    if (!customElements.get('vortex-ultra-orbits')) {
      customElements.define('vortex-ultra-orbits', VortexUltraOrbits);
      const old = document.querySelector('vortex-ultraslow');
      if (old) {
        const repl = document.createElement('vortex-ultra-orbits');
        old.replaceWith(repl);
      }
    }
  }
})();
</script>
