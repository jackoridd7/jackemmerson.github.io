<script>
/* ultraslow vortex, grid-stepped (inline-lock-r16)
   - One-letter-per-cell with de-dup
   - Max ONE cell move per ~1s per glyph (intro slower)
   - No fast flicker: characters advance 1 symbol every 5s
*/
(function(){
  class VortexUltraSlow extends HTMLElement {
    connectedCallback(){
      // Config
      this.words = ["TRAJECTORY","PROPULSION","Δv","CFD","REENTRY","ORBITAL","STARSHIP","MARS","SPICE","ROVER","SCRAMJET","UAV"];
      const CELL_W=12, CELL_H=36;        // 2× size
      const ROWS=40, B=4.2;              // r = B*θ
      const CENTER_X=0.5, CENTER_Y=0.58; // keep hero above centre
      const BOOT_MS=3000;                // rows phase
      const SPEED_INTRO=0.000005;        // rad/s (almost still)
      const SPEED_FINAL=0.0005;          // rad/s (glacial)
      const STEP_INTRO_MS=1400;          // cell change cooldown at start
      const STEP_FINAL_MS=1000;          // cell change cooldown after morph
      const VERSION="inline-lock-r16";

      // Build line (no spaces)
      const line = (this.words.join("•")+"•").replace(/ /g,"");

      // Canvas
      const cvs = document.createElement("canvas");
      const ctx = cvs.getContext("2d");
      this.appendChild(cvs);

      // Sizing/init
      const resize = () => {
        const dpr = Math.max(1, devicePixelRatio||1);
        cvs.width  = Math.floor(innerWidth*dpr);
        cvs.height = Math.floor(innerHeight*dpr);
        cvs.style.width  = innerWidth+"px";
        cvs.style.height = innerHeight+"px";
        ctx.setTransform(dpr,0,0,dpr,0,0);

        this.cx = innerWidth*CENTER_X;
        this.cy = innerHeight*CENTER_Y;

        // Font & cell sanity
        this.fontPx = Math.max(10, Math.floor(CELL_H*0.61));
        ctx.font = `${this.fontPx}px "Courier New", monospace`;
        const mw = Math.ceil(ctx.measureText("M").width)+2;
        this.cellW = Math.max(CELL_W, mw);
        this.cellH = CELL_H;

        // Grid
        this.cols = Math.max(1, Math.floor(innerWidth / this.cellW));
        this.rows = Math.max(1, ROWS);
        this.N    = Math.min(this.cols*this.rows, 12000);

        const maxR = Math.hypot(Math.max(this.cx, innerWidth-this.cx),
                                Math.max(this.cy, innerHeight-this.cy)) + 60;
        this.maxTheta = maxR / B;

        // θ inner→outer
        this.theta = new Float32Array(this.N);
        for (let i=0;i<this.N;i++) this.theta[i] = (i/this.N)*this.maxTheta;

        // Matrix mapping and state
        this.rcRow = new Int16Array(this.N);
        this.rcCol = new Int16Array(this.N);
        this.lastCi = new Int16Array(this.N);
        this.lastRi = new Int16Array(this.N);
        this.nextAt = new Float64Array(this.N); // ms timestamp for next allowed step
        let k=0, now=performance.now();
        for (let r=0;r<this.rows && k<this.N;r++){
          for (let c=0;c<this.cols && k<this.N;c++,k++){
            this.rcRow[k]=r; this.rcCol[k]=c;
            this.lastCi[k]=c; this.lastRi[k]=r;
            this.nextAt[k]=now; // can move immediately when allowed
          }
        }

        this.occ = new Uint8Array(this.cols*this.rows);
      };
      addEventListener("resize", resize, {passive:true}); resize();

      const ease = t => t<.5 ? 4*t*t*t : 1-(-2*t+2)**3/2;

      this.__version = VERSION;
      let tStart = performance.now(), tPrev = tStart;

      const tick = (now) => {
        const dt = Math.min(1/20, Math.max(0,(now - tPrev)/1000)); tPrev = now;

        ctx.clearRect(0,0,innerWidth,innerHeight);
        ctx.fillStyle   = "#d7e0ee";
        ctx.font        = `${this.fontPx}px "Courier New", monospace`;
        ctx.textAlign   = "center";
        ctx.textBaseline= "middle";

        // Morph and speed
        const mRaw = Math.min(1, Math.max(0,(now - tStart - BOOT_MS)/1200));
        const morph = ease(mRaw);
        const speedNow = SPEED_INTRO + (SPEED_FINAL - SPEED_INTRO)*morph;

        // Step interval (ms) blends intro→final
        const stepMs = STEP_INTRO_MS + (STEP_FINAL_MS - STEP_INTRO_MS)*morph;

        // Very slow text cycling: 1 symbol every 5s
        const charOffset = Math.floor(now / 5000) % line.length;

        // Reset occupancy
        this.occ.fill(0);
        const halfRowsH = (ROWS*this.cellH)/2;

        // Draw inner→outer
        for (let i=0;i<this.N;i++){
          let t = this.theta[i];
          if (t > this.maxTheta){ t -= this.maxTheta; this.theta[i]=t; }
          const r = B*t;

          // Spiral pos
          const sx = this.cx + r*Math.cos(t);
          const sy = this.cy + r*Math.sin(t);

          // Row pos
          const rx = (this.rcCol[i] + 0.5) * this.cellW;
          const ry = (this.rcRow[i] + 0.5) * this.cellH + (this.cy - halfRowsH);

          // Mix, then target cell
          let x = rx*(1-morph) + sx*morph;
          let y = ry*(1-morph) + sy*morph;
          const ciT = Math.round(x / this.cellW);
          const riT = Math.round(y / this.cellH);

          // Current cell from state
          let ci = this.lastCi[i];
          let ri = this.lastRi[i];

          // Move at most ONE cell per step interval (and only if time allows)
          if ((ciT!==ci || riT!==ri) && now >= this.nextAt[i]) {
            const dci = ciT - ci, dri = riT - ri;
            if (Math.abs(dci) >= Math.abs(dri)) {
              ci += Math.sign(dci) || 0;
            } else {
              ri += Math.sign(dri) || 0;
            }
            // Clamp
            if (ci<0) ci=0; if (ci>=this.cols) ci=this.cols-1;
            if (ri<0) ri=0; if (ri>=this.rows) ri=this.rows-1;

            this.lastCi[i]=ci; this.lastRi[i]=ri;
            this.nextAt[i]= now + stepMs; // schedule next allowed step
          }

          // One letter per cell (de-dup)
          const key = ri*this.cols + ci;
          if (!this.occ[key]) {
            this.occ[key]=1;
            const px = ci*this.cellW, py = ri*this.cellH;
            const ch = line.charAt((i + charOffset) % line.length) || "•";
            ctx.fillText(ch, px, py);
          }

          // Advance θ (time-based)
          this.theta[i] = t + speedNow*dt;
        }

        // HUD
        ctx.save();
        ctx.fillStyle = "rgba(2,6,23,.6)";
        ctx.fillRect(8,8,290,54);
        ctx.fillStyle = "#cbd5e1";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace";
        ctx.textAlign="left"; ctx.textBaseline="top";
        ctx.fillText(VERSION, 16, 14);
        ctx.fillText(`morph=${morph.toFixed(2)} speed=${speedNow.toFixed(6)} rad/s  step≈${Math.round(stepMs)}ms`, 16, 30);
        ctx.restore();

        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }
  }
  if (!customElements.get('vortex-ultraslow')) {
    customElements.define('vortex-ultraslow', VortexUltraSlow);
  }
})();
</script>
