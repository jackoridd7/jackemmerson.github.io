<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jack Emmerson – Designing Tomorrow</title>

  <!-- Visibility hot-fix -->
  <style id="hotfix-visible">html,body{opacity:1!important;background:#0f172a!important}</style>
  <script>
    (()=>{const f=()=>{document.documentElement.style.opacity='1';document.body.style.opacity='1'};document.addEventListener('DOMContentLoaded',f,{once:true});addEventListener('click',e=>{if(e.target?.closest?.('a'))f()},true)})();
  </script>

  <style>
    :root { --bg1:#0f172a; --bg2:#020617; --ink:#e2e8f0; --muted:#94a3b8; }
    * { box-sizing: border-box }
    html,body{height:100%}
    body{
      margin:0; color:var(--ink);
      background: radial-gradient(1200px 800px at 50% 40%, var(--bg1), var(--bg2));
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji",sans-serif;
    }

    /* Layout */
    .nav{position:fixed; inset-inline:0; top:0; z-index:20;}
    .nav .row{max-width:1100px; margin:0 auto; padding:20px 24px; display:flex; align-items:center; justify-content:space-between;}
    .nav a{color:#cbd5e1; text-decoration:none; margin-left:24px}
    .nav a:hover{color:#6ee7b7}
    .brand{display:inline-block; width:28px; height:28px; border-radius:10px; background:#10b981; margin-right:10px; vertical-align:middle}

    .hero{min-height:100vh; display:grid; place-items:center; padding:96px 24px 24px; position:relative; z-index:10;}
    .hero .card{text-align:center; max-width:820px; transform:translateY(-10vh)}
    .h1{
      font-weight:800; font-size:clamp(44px,8vw,84px); line-height:1.05; margin:0;
      background:linear-gradient(90deg,#A7F3D0,#CCFBF1,#67E8F9);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      letter-spacing:.5px;
    }
    .sub{margin-top:18px; color:var(--muted); font-size:18px}
    .btns{margin-top:28px; display:flex; gap:14px; justify-content:center}
    .pill{padding:12px 28px; border-radius:9999px; border:1px solid rgba(255,255,255,.15); backdrop-filter:saturate(180%) blur(6px)}
    .pill.primary{background:rgba(16,185,129,.18); color:#6ee7b7; border-color:rgba(16,185,129,.30)}
    .pill.primary:hover{background:rgba(16,185,129,.28)}
    .pill.ghost{background:rgba(255,255,255,.08); color:#e5e7eb}
    .pill.ghost:hover{background:rgba(255,255,255,.16)}

    /* Effect layer */
    vortex-show{position:fixed; inset:0; z-index:0; pointer-events:none; display:block}
    .scanlines{position:fixed; inset:0; z-index:1; pointer-events:none;
      background-image:repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0, rgba(255,255,255,.03) 1px, transparent 1px, transparent 3px);
    }

    footer{position:relative; z-index:10; text-align:center; color:#94a3b8; font-size:14px; padding:24px 0}
    .hud{position:fixed; left:8px; top:8px; z-index:50; background:rgba(2,6,23,.65); color:#cbd5e1;
         padding:6px 10px; border-radius:6px; font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace}
  </style>
</head>
<body>
  <vortex-show></vortex-show>
  <div class="scanlines"></div>

  <!-- NAV -->
  <header class="nav">
    <div class="row">
      <div><span class="brand"></span><strong>Jack Emmerson</strong></div>
      <div>
        <a href="index.html">Jack</a>
        <a href="tools.html">Tools</a>
        <a href="shop.html">Shop</a>
      </div>
    </div>
  </header>

  <!-- HERO -->
  <main class="hero">
    <section class="card">
      <h1 class="h1">Designing&nbsp;Tomorrow</h1>
      <p class="sub">Aerospace engineering, CFD wizardry &amp; orbital mechanics — built in public.</p>
      <div class="btns">
        <a class="pill primary" href="tools.html">Explore Tools</a>
        <a class="pill ghost" href="mailto:sidwellcourtney@gmail.com">Contact</a>
      </div>
    </section>
  </main>

  <footer>© 2025 Jack Emmerson</footer>
  <div id="hud" class="hud">booting…</div>

  <!-- EFFECT: intro right-slide → spiral → static grid masked by planet discs  (inline-orbits-r22) -->
  <script>
  (function(){
    /* ===================== Config ===================== */
    // Planets (Mercury..Jupiter only; Jupiter outermost)
    const PLANETS = [
      {name:"Mercury", a:0.3871, P:  87.969, color:"#cbd5e1", dot:2, disc:22},
      {name:"Venus",   a:0.7233, P: 224.701, color:"#fbbf24", dot:3, disc:26},
      {name:"Earth",   a:1.0000, P: 365.256, color:"#60a5fa", dot:3, disc:28},
      {name:"Mars",    a:1.5237, P: 686.980, color:"#f87171", dot:3, disc:26},
      {name:"Jupiter", a:5.2026, P:4332.590, color:"#f59e0b", dot:4, disc:34}
    ];

    // Phases
    const INTRO_SECS   = 3.0;     // readable right-slide
    const SPIRAL_MS    = 1200;    // rows → spiral morph
    const ORBIT_FADE_MS= 700;     // fade to disc-only reveal

    // Intro motion
    const SLIDE_PX_PER_SEC = 28;  // slide right speed

    // Spiral
    const B_SPIRAL = 4.2;         // r = B * θ
    const SPEED_RAD_S = 0.012;    // angular drift during spiral

    // Grid
    const CELL_W=12, CELL_H=36, ROWS=40;
    const CENTER_X=0.5, CENTER_Y=0.58;

    // Solar time
    const DAYS_PER_SEC = 30;

    // Text content
    const WORDS = ["TRAJECTORY","PROPULSION","Δv","CFD","REENTRY","ORBITAL","STARSHIP","MARS","SPICE","ROVER","SCRAMJET","UAV"];
    const LINE = (WORDS.join("•")+"•").replace(/ /g,"");

    /* ===================== Helpers ===================== */
    const clamp01 = x => Math.max(0, Math.min(1, x));
    const easeCubic = t => (t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2);
    const lerp = (a,b,t) => a + (b-a)*t;

    /* ===================== Custom element ===================== */
    class VortexShow extends HTMLElement {
      connectedCallback(){
        // Canvas
        this.c = document.createElement('canvas');
        this.x = this.c.getContext('2d', {alpha:true});
        this.appendChild(this.c);

        // Sizing and precompute
        const resize = () => {
          const dpr = Math.max(1, devicePixelRatio||1);
          this.c.width  = Math.floor(innerWidth*dpr);
          this.c.height = Math.floor(innerHeight*dpr);
          this.c.style.width  = innerWidth+"px";
          this.c.style.height = innerHeight+"px";
          this.x.setTransform(dpr,0,0,dpr,0,0);

          // Center
          this.cx = innerWidth*CENTER_X;
          this.cy = innerHeight*CENTER_Y;

          // Font & cell
          this.fontPx = Math.max(10, Math.floor(CELL_H*0.61));
          this.x.font = `${this.fontPx}px "Courier New", monospace`;
          const mw = Math.ceil(this.x.measureText("M").width)+2;
          this.cellW = Math.max(CELL_W, mw);
          this.cellH = CELL_H;

          // Max right slide we will do
          const slideMax = SLIDE_PX_PER_SEC * INTRO_SECS;
          const extraCols = Math.ceil(slideMax / this.cellW) + 2; // pad left & right

          // Grid width extended to avoid gaps while sliding right
          this.cols = Math.max(1, Math.floor((innerWidth + extraCols*this.cellW*2) / this.cellW));
          this.rows = Math.max(1, ROWS);
          this.N    = Math.min(this.cols*this.rows, 16000);

          // Shift so that we have padding to the left equal to slideMax
          this.gridOffsetX = -extraCols*this.cellW;

          // Row/col mapping (row-major)
          this.rcR = new Int16Array(this.N);
          this.rcC = new Int16Array(this.N);
          let k=0;
          for (let r=0;r<this.rows && k<this.N;r++){
            for (let c=0;c<this.cols && k<this.N;c++,k++){
              this.rcR[k]=r; this.rcC[k]=c;
            }
          }

          // Static base Y positions (no vertical drift)
          this.y0 = this.cy - (this.rows*this.cellH)/2;

          // Spiral precompute limits
          const maxR = Math.hypot(Math.max(this.cx, innerWidth-this.cx),
                                  Math.max(this.cy, innerHeight-this.cy)) + 60;
          this.maxTheta = maxR / B_SPIRAL;
          this.theta = new Float32Array(this.N);
          for (let i=0;i<this.N;i++) this.theta[i]=(i/this.N)*this.maxTheta;

          // Scale orbits so Jupiter is ~45% of min dimension
          const minDim = Math.min(innerWidth, innerHeight);
          const kpx = (0.45 * minDim) / 5.2026; // Jupiter a
          this.orbitR = PLANETS.map(p => p.a * kpx);

          // Planet phases/rates
          const daysNow = Date.now()/86400000;
          this.ang0  = PLANETS.map(p => 2*Math.PI*((daysNow % p.P)/p.P));
          this.omega = PLANETS.map(p => 2*Math.PI*(DAYS_PER_SEC/p.P));
        };
        addEventListener('resize', resize, {passive:true});
        resize();

        this.t0 = performance.now();
        this.last = this.t0;
        this.tick = this.tick.bind(this);
        requestAnimationFrame(this.tick);
      }

      tick(now){
        const dt = Math.min(1/20, Math.max(0,(now - this.last)/1000)); this.last = now;
        const x = this.x, w = innerWidth, h = innerHeight;
        x.clearRect(0,0,w,h);
        x.textAlign="center"; x.textBaseline="middle"; x.fillStyle="#d7e0ee";
        x.font = `${this.fontPx}px "Courier New", monospace`;

        // Phases: intro slide → spiral morph → orbit reveal
        const tIntroMs = INTRO_SECS*1000;
        const tSpiralStart = this.t0 + tIntroMs;
        const tSpiralEnd   = tSpiralStart + SPIRAL_MS;
        const tFadeEnd     = tSpiralEnd + ORBIT_FADE_MS;

        const introT   = clamp01((now - this.t0)/tIntroMs);
        const spiralT  = clamp01((now - tSpiralStart)/SPIRAL_MS);
        const fadeT    = clamp01((now - tSpiralEnd)/ORBIT_FADE_MS);

        const introSlide = SLIDE_PX_PER_SEC * (introT * INTRO_SECS);        // px
        const spiralMorph = easeCubic(spiralT);                              // 0→1
        const fadeMorph   = easeCubic(fadeT);                                // 0→1

        // Planet positions
        const tSec = (now - this.t0)/1000;
        const px=[], py=[];
        for (let k=0;k<this.orbitR.length;k++){
          const a = this.ang0[k] + this.omega[k]*tSec;
          px[k] = this.cx + this.orbitR[k]*Math.cos(a);
          py[k] = this.cy + this.orbitR[k]*Math.sin(a);
        }

        // Draw letters
        const len = LINE.length;
        const charOffset = Math.floor(now/5000) % len;

        for (let i=0;i<this.N;i++){
          // Base grid position (strictly horizontal slide, fixed rows)
          const r = this.rcR[i], c = this.rcC[i];
          const baseX = (c + 0.5) * this.cellW + this.gridOffsetX + introSlide*(1-spiralMorph);
          const baseY = (r + 0.5) * this.cellH + this.y0;

          // Spiral position (animated by θ)
          let th = this.theta[i];
          if (th > this.maxTheta){ th -= this.maxTheta; this.theta[i]=th; }
          const rad = B_SPIRAL * th;
          const sx  = this.cx + rad*Math.cos(th);
          const sy  = this.cy + rad*Math.sin(th);

          // Position blend across spiral phase
          const xPos = baseX*(1-spiralMorph) + sx*spiralMorph;
          const yPos = baseY*(1-spiralMorph) + sy*spiralMorph;

          // Reveal mode: after fade completes, show only inside planet discs
          let visible = true;
          if (fadeMorph > 0){ // being revealed / revealed
            visible = false;
            // Check disc inclusion; mix visibility as we fade
            for (let k=0;k<this.orbitR.length;k++){
              const dx = xPos - px[k], dy = yPos - py[k];
              if (dx*dx + dy*dy <= PLANETS[k].disc*PLANETS[k].disc) { visible = true; break; }
            }
            // During fade window, lerp visibility (simple alpha gate)
            if (!visible && fadeMorph < 1) { /* keep hidden during fade */ }
          }

          if (visible) {
            const ch = LINE.charAt((i + charOffset) % len) || "•";
            x.fillText(ch, xPos, yPos);
          }

          // θ drift only during spiral phase (so spiral feels alive)
          if (spiralMorph < 1) this.theta[i] = th + SPEED_RAD_S*dt;
        }

        // Draw planets (solid dots)
        x.save();
        for (let k=0;k<this.orbitR.length;k++){
          x.fillStyle = PLANETS[k].color;
          x.beginPath(); x.arc(px[k], py[k], PLANETS[k].dot, 0, Math.PI*2); x.fill();
        }
        x.restore();

        // HUD
        const hud = document.getElementById('hud');
        if (hud) hud.textContent =
          `inline-orbits-r22 | intro=${introT.toFixed(2)} spiral=${spiralMorph.toFixed(2)} fade=${fadeMorph.toFixed(2)} | cols=${this.cols}`;

        requestAnimationFrame(this.tick);
      }
    }

    const TAG='vortex-show';
    if (!customElements.get(TAG)) customElements.define(TAG, VortexShow);
  })();
  </script>
</body>
</html>
